(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[1],{

/***/ "./src/js/api/password_manager.js":
/*!****************************************!*\
  !*** ./src/js/api/password_manager.js ***!
  \****************************************/
/*! exports provided: getInputPasswordSRP */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getInputPasswordSRP\", function() { return getInputPasswordSRP; });\nasync function getInputPasswordSRP(password, accountPassword) {\n  const {\n    bufferConcat,\n    bigBytesInt,\n    bigint,\n    bufferRandom,\n    bytesPowMod,\n    bytesXor\n  } = await __webpack_require__.e(/*! import() */ 2).then(__webpack_require__.bind(null, /*! ../mtproto/bin.js */ \"./src/js/mtproto/bin.js\"));\n  const {\n    sha256Hash\n  } = await __webpack_require__.e(/*! import() */ 2).then(__webpack_require__.bind(null, /*! ../mtproto/crypto.js */ \"./src/js/mtproto/crypto.js\"));\n  return await calcInputPassword(password, accountPassword);\n\n  async function SH(data, salt) {\n    return await sha256Hash(bufferConcat(salt, data, salt));\n  }\n\n  async function calcPasswordHash(password, salt1, salt2) {\n    const buf = await SH((await SH(password, salt1)), salt2);\n    const key = await crypto.subtle.importKey('raw', buf, 'PBKDF2', false, ['deriveBits']);\n    const hash = await crypto.subtle.deriveBits({\n      name: 'PBKDF2',\n      hash: 'SHA-512',\n      salt: salt1,\n      iterations: 100000\n    }, key, 512);\n    return SH(hash, salt2);\n  }\n\n  async function calcInputPassword(password, srpParams) {\n    const {\n      srp_B: B,\n      srp_id\n    } = srpParams;\n    const {\n      p,\n      salt1,\n      salt2\n    } = srpParams.current_algo;\n    const g = new Uint8Array([srpParams.current_algo.g]);\n    const p_bn = bigBytesInt(p);\n    const B_bn = bigBytesInt(B);\n    const zero_bn = bigint(0);\n    const g_padded = new Uint8Array(256);\n    g_padded.set(g);\n    g_padded.reverse();\n    const a = new Uint8Array(bufferRandom(256));\n    const a_bn = bigBytesInt(a);\n    const A = await bytesPowMod(g, a, p);\n    const [x, u, k] = await Promise.all([calcPasswordHash(new TextEncoder().encode(password), salt1, salt2), sha256Hash(bufferConcat(A, B)), sha256Hash(bufferConcat(p, g_padded))]);\n    const v = await bytesPowMod(g, x, p);\n    const kv_bn = bigBytesInt(k).multiply(bigBytesInt(v)).mod(p_bn);\n    let t_bn = B_bn.subtract(kv_bn).mod(p_bn);\n\n    if (t_bn.compareTo(zero_bn) < 0) {\n      t_bn = t_bn.add(p_bn);\n    }\n\n    const exp = a_bn.add(bigBytesInt(u).multiply(bigBytesInt(x))).toByteArray();\n    const S = await bytesPowMod(t_bn.toByteArray(), exp, p);\n    const S_padded = new Uint8Array(256);\n    S_padded.set(S);\n    const [K, h1, h2, hs1, hs2] = await Promise.all([sha256Hash(S_padded), sha256Hash(p), sha256Hash(g_padded), sha256Hash(salt1), sha256Hash(salt2)]);\n    const M1 = await sha256Hash(bufferConcat(bytesXor(h1, h2), hs1, hs2, A, B, K));\n    return {\n      srp_id,\n      A,\n      M1\n    };\n  }\n}\n\n\n\n//# sourceURL=webpack:///./src/js/api/password_manager.js?");

/***/ })

}]);